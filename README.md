# Feba-GitHub
Це репрозій для моєї гри "Feba". Гра про знищування квадратиків курсором.
import pygame          ### імпортую модуль pygame
from random import randint   ### імпортую функцію для генерування випадкових чисел
pygame.init()    ### імпортую всі функції
window = pygame.display.set_mode((670,500)) ### створюю вікно 670 на 500
COLOR=(225,225,225) ### Колір фону
window.fill(COLOR)  ### заповнюю вікно коліром фону
clock = pygame.time.Clock()  ### кадри за секунду
pygame.display.set_caption("Feba")  ### назва гри Feba
font1 = pygame.font.Font(None, 50) # створення звичайного шрифту
#pygame.display.set_mode((670,500), pygame.DOUBLEBUF | pygame.HWSURFACE | pygame.FULLSCREEN) ### ЕКСПЕРМЕНТ!
class Knopka(): # cтворюю клас Knopka яким я роблю всі прямокутники і текст:
    def __init__( self, x, y, p_x, p_y, question1, p_c_1 = 0, p_c_2 = 0, p_c_3 = 0, t_c_1 = 0, t_c_2 = 0, t_c_3 = 0, r = 1, ra = 1, ran = 7 ): ### всі атребути кнопки
        self.x          = x         # положення кнопки по осі X
        self.y          = y         # положення кнопки по осі Y
        self.p_x        = p_x       # довжина кнопки
        self.p_y        = p_y       # ширина кнопки
        self.question1  = question1 # текст на кнопці
        self.p_c_1      = p_c_1     # колір прямокутника (RGB)
        self.p_c_2      = p_c_2     # колір прямокутника (RGB)
        self.p_c_3      = p_c_3     # колір прямокутника (RGB)
        self.t_c_1      = t_c_1     # колір текстуку (RGB)
        self.t_c_2      = t_c_2     # колір текстуку (RGB)
        self.t_c_3      = t_c_3     # колір текстуку (RGB)
        self.speed_x    = r         # це для того наскільки швитко рухатиметься квадрат по горизонталі
        self.speed_y    = ra        # а це для того наскільки швитко рухатиметься квадрат по вертикалі
        self.width      = ran       # розмір квадратів
    def f(self): ### функція для малювання кнопки:
        rect1 = pygame.Rect(self.x, self.y, self.p_x, self.p_y) # створення прямокутника
        pygame.draw.rect(window, (self.p_c_1, self.p_c_2, self.p_c_3), rect1)  # малювання прямокутника
        question = font1.render(self.question1, True, (self.t_c_1, self.t_c_2, self.t_c_3)) # створення тексту
        window.blit(question, (self.x, self.y + self.p_y / 2)) # малювання тексту
    def g( self, enemy ): ### функція для визначення того чи торкається кнопка іншої кнопки
        if self.y + self.p_y <= enemy.y or self.y >= enemy.y + enemy.p_y or self.x + self.p_x <= enemy.x or self.x >= enemy.x + enemy.p_x: # .
            return False # якщо не торкається: ні
        else:            # інакше:
            return True  # так
#### Створення майже всіх кнопок
tab = Knopka(502,7,0,0,'0',0,0,0,255,255,255) # текст скільки я знищив кубів
mouse = Knopka(4000,4000,1,1,' ') # маленька кнопка яка завжди там де мишка (для того щоб перевіряти чи доторкаюсь мишкою до інших кнопок)
d1 = Knopka(500,0,171,501,' ',0,0,0) # вкеликий прямокутник справа
lvl= Knopka(502,47,0,0,'0',0,0,0,255,255,255) # текст який зараз рівень
d2 = Knopka(500,100,171,400,' ',100,0,0) # інший прямокутник справа
d3 = Knopka(500,500,170,500,' ',0,250,0) # шкала досвіду
the_end = Knopka(200,200,0,0,' ',0,0,0,0,0,0) # напис " Кінець! " який появляється при закінченні гри
fon= Knopka(0,501,500,500,' ',0,0,0) # прямокутник який появляється знизу і на ньому буде статистика
v1 = Knopka(10,450,0,0,'0' , 0,0,0 , 0,0,0 ) # статистика скільки разів я програв
v2 = Knopka(10,400,0,0,'0' , 0,0,0 , 0,0,0 ) # статистика який зараз рівень
v3 = Knopka(10,350,0,0,'0' , 0,0,0 , 0,0,0 ) # статистика скільки знижено кубів загалом
v4 = Knopka(10,300,0,0,'0' , 0,0,0 , 0,0,0 ) # статистика скільки знижено кубів за цю гру
p1 = Knopka(0,0,22,22,' ',0,0,0)        # 1 пауза складається з чотирьох кнопок
p2 = Knopka(1,1,20,20,' ',200,200,250)  # 2 пауза
p3 = Knopka(5.5,6,4,10,' ',100,100,250) # 3 пауза
p4 = Knopka(13.5,6,4,10,' ',100,100,250)# 4 пауза
pausa = Knopka(200,185,0,0,' Пауза',0,0,0,100,100,250) # натпис " Пауза " під час паузи
#### Майже усі змінні і списки які є у грі
program_work = True # чи працює програма
x_kubas = 0 # скільки я знижив кубів за усю гру
x_lose  = 0 # скільки разів я програв
q1 , q2 , q3 , q4 = 0 , 0 , 0 , 0 # змінні для тексту у статистиці
m_fon = 0 # прямокутник який появляється знизу і на ньому буде статистика
kubas = 0 # скільки я знижив кубів за цю гру
start_i = 100 # як часто появляються два куби
progres1, progres2 = 5 , 0 # скільки треба знижити кубів щоб підняти рівень, і скільки я їх вже знищив після підняття рівня
lvl1 = 1 # рівень
str1 = 6 # як швидко я буду знищувати куби
i = 125 # змінна яка постійно зменшується і коли == 0 то появляється 2 куби
HP = 255 # скільки ще кубів може впасти
kubs = [] # список у який я добавляю куби
kubes= [] # список у який я добавляю частинки які розлітаються з кубів
#### Усі функції які я зробив
def kubis(b): ### створення частинок які розлітаються з кубів
    for i in range(3): ## повторюю це три рази
        kube = Knopka(0,0,0,0,str(randint(0,1)),0,0,0,0,randint(200,255),0,randint(-20,20)/10,randint(-40,-20)/10) # створюю частинку (0 або 1)
        kube.x = b.x + 10 # переміщання на центр куба по горизонталі
        kube.y = b.y + 10 # переміщання на центр куба по вертикалі
        kubes.append(kube) # додаю частинку у список кубес
##### Цикл (події які відбуваються 45 разів на секунду):
while program_work: ### Повторюється поки не закрити програму
    COLOR = (225,HP,HP) # зміна коляру фону (чим більше кубів впало тим черваніший екран)
    window.fill(COLOR) # замальовую фон кольором фону
    mouse.x,mouse.y = pygame.mouse.get_pos() # змінюю положення миші
    for event in pygame.event.get(): # перебираю всі події
        if event.type == pygame.QUIT: # якщо натиснутий хрестик:
            program_work = False      # закрити програму
    #### Малювання кнопок і всяке таке
    if m_fon > 0: # це для плавного
        m_fon -= 1# переходу вверх чрного прямокутниа
    fon.y -= m_fon# рух вгору
    fon.f()# малюю чорний прямокутник
    d1.f() # малюю інший прямокутник
    d2.f() # малюю ще інший прямокутник
    d3.y = 500 - (progres2 * (d2.p_y / progres1)) # змінюю довжину шкали досвіду
    d3.f() # малюю шкалу досвіду
    tab.question1 = 'куби ' + str(x_kubas) # зміна тексту на статистиці скільки я знищив кубів
    tab.f() # малюю скільки я знищив кубів
    lvl.question1 = 'рівень ' + str(lvl1) # зміна тексту на статистиці який рівень
    lvl.f() # малюю який рівень
    the_end.f() # малюю ще одну кнопку на якій пише " Кінець! "
    v1.question1 = ' Програшів: ' + str(int(q1))      # змінюю текст на статистиці в кінці
    v2.question1 = ' Рівень: ' + str(int(q2))         # змінюю текст на статистиці в кінці
    v3.question1 = ' Всі куби: ' + str(int(q3))       # змінюю текст на статистиці в кінці
    v4.question1 = ' Куби за цю гру: ' + str(int(q4)) # змінюю текст на статистиці в кінці
    p = 1 # змінна щоб малювати паузу тільки раз
    i -= 1 # зменшую змінну "і" на 1
    #### Це відповідає за рівні
    if progres1 == progres2: # якщо знищена потрібна кількість кубів:
        progres1 += 5 # збільшую потрібну кількість кубів яка потрібна для збільшення рівня на 5
        progres2 = 0 # куби після закінчення рівню = 0
        lvl1 += 1 # збільшую рівень на 1
        str1 += 3 # знищувати кубів простше
    #### статистика в кінці
    if i == -250: # через певний час після того як куби закінчились:
        the_end.question1 = 'Кінець!' # добавляю надпис " Кінець! "
    elif i == -300: # через ще певний час після того як куби закінчились:
        if x_kubas == kubas: # якщо ми не програвали:
            m_fon = 19 # посунути чорну кнопку вверх
        else: # інакше:
            m_fon = 22 # посунути чорну кнопку вверх але вище
    elif i <= -350: # через ще довший час після того як куби закінчились (це все щоб було гарно):
        if v1.t_c_1 < 255: # якщо ті кнопки ще не білі:
            ## статистика скільки разів я програв |
            v1.t_c_1 += 5 # робить кнопку білішою |
            v1.t_c_2 += 5 # робить кнопку білішою |
            v1.t_c_3 += 5 # робить кнопку білішою |
            ##       статистика який зараз рівень |
            v2.t_c_1 += 5 # робить кнопку білішою |
            v2.t_c_2 += 5 # робить кнопку білішою |
            v2.t_c_3 += 5 # робить кнопку білішою |
            ## 1 статистика скільки знижено кубів |
            v3.t_c_1 += 5 # робить кнопку білішою |
            v3.t_c_2 += 5 # робить кнопку білішою |
            v3.t_c_3 += 5 # робить кнопку білішою |
            ## 2 статистика скільки знижено кубів |
            v4.t_c_1 += 5 # робить кнопку білішою |
            v4.t_c_2 += 5 # робить кнопку білішою |
            v4.t_c_3 += 5 # робить кнопку білішою |
        else: # після цього:
            if kubas > q4 and x_kubas != kubas: # якщо ми програвали:
                q4 += kubas / 40 # плавне збільшення числа
            else: # інакше
                if x_kubas > q3: # якщо ще не збільшилось
                    q3 += x_kubas / 40 # плавне збільшення числа
                else: # після цього:
                    if lvl1 > q2: # якщо ще не збільшилось
                        q2 += lvl1 / 40 # плавне збільшення числа
                    else: # після цього:
                        if x_lose > q1: # якщо ще не збільшилось
                            q1 += x_lose / 40 # плавне збільшення числа
        v1.f() # малюємо скільки програшів
        v2.f() # малюємо рівень
        v3.f() # малюємо загальні куби
        if kubas == x_kubas: # якщо ми не програвали:
            a = 1 # нічого не робимо
        else: # інакше
            v4.f() # малюємо знищені куби за цю гру
    #### ставорюю 2 куби
    if i == 0: # якщо "i" = 0:-
        i = start_i # "i" = змінна "старт_і"
        start_i -= 1# змінна "старт_і" зменшується на 1
        for j in range(2): # повторити 2 рази
            kub = Knopka(0,0,0,0,' ',0,200,0,0,0,0,randint(-2,2),randint(-31,-26)/3,randint(40,60)) # створюю куб
            kub.x = randint( 20, 400 - kub.width ) # переміщення куба в випадкове місце по горизонталі
            kub.y = 501 # переміщую куб знизу під екран
            kub.p_x = kub.width # задаємо довжину куба
            kub.p_y = kub.width # задаємо ширину куба
            kubs.append(kub) # додає куб у список кубс
    #### частинки 45 разів на секунду
    for b in kubes: ## всі частинки у списку:
        b.speed_y += 0.15# зменщуємо швидкість польоту вверх, і збільшуємо швидкість польоту вниз
        b.x += b.speed_x # зміна положення частинки по горизонталі залежно від швидкості
        b.y += b.speed_y # зміна положення частинки по вертикалі залежно від швидкості
        if b.x < 6 or b.x + b.width > 494: # якщо торкається лівої або правої стіни:
            b.speed_x = -b.speed_x # рухатись в іншу сторну по горизонталі
        if b.y > 501: # якщо надто низько:
            kubes.remove(b) # видалити цю частинку з списку
        b.f() # малювати частинку
    #### куби 45 разів на секунду
    for b in kubs: # всі куби у списку:
        b.speed_y += 0.1 # зменщуємо швидкість польоту вверх, і збільшуємо швидкість польоту вниз
        b.x += b.speed_x # зміна положення куба по горизонталі залежно від швидкості
        b.y += b.speed_y # зміна положення куба по вертикалі залежно від швидкості
        if b.x < 6 or b.x + b.width > 494: # якщо торкається лівої або правої стіни:
            b.speed_x = -b.speed_x # рухатись в іншу сторну по горизонталі
        if b.y > 600: # якщо надто низько:
            kubs.remove(b) # видалити цей куб із списку
            HP -= 10 # зробити фон червонішим
        if b.p_c_1 > 150:  # якщо куб достатньо червоний:
            kubs.remove(b)# видалити цей куб з списку
            kubis(b)      # створення частинок
            kubas += 1    # +1 до того скільки знищино кубів за цю гру
            progres2 += 1 # +1 до того скільки знищино кубів після підвищення рівню
            x_kubas += 1  # +1 до того скільки знищино кубів загалом
        if b.g(mouse): # якщо куб торкається миші:
            if b.p_c_1 + str1 > 150: # якщо куб буде достатньо червоний:
                kubs.remove(b)# видалити цей куб з списку
                kubis(b)      # створити частинки
                kubas += 1    # +1 до того скільки знищино кубів за цю гру
                progres2 += 1 # +1 до того скільки знищино кубів після підвищення рівню
                x_kubas += 1  # +1 до того скільки знищино кубів загалом
            else: # інакше:
                b.p_c_2 -= str1 # зробити куб менш зеленим
                b.p_c_1 += str1 # зробити куб більш червоним
        b.f() # намалювати куб
    #### перевірка чи поставили ми на паузу
    if mouse.g(p1): # якщо миша торкається паузи:
        pasa = True  # так
    else: # інакше:
        pasa = False # ні
    #### малювання всіх кнопок які відповідають за паузу
    p1.f() # кнопка 1
    p2.f() # кнопка 2
    p3.f() # кнопка 3
    p4.f() # кнопка 4
    #### цикл для перебування у паузі
    while pasa == True and i >= -250: # поки пауза і гра ще не закінчилась
        mouse.x,mouse.y = pygame.mouse.get_pos() # зміна положення миші
        for event in pygame.event.get(): # перегляд всіх подій
            if event.type == pygame.QUIT: # якщо ця подія це натискання на хрестик:
                a = 2 + "2" # дуже складна математична задача через яку програма закриється
        if p == 1: # якщо можна малювати паузу:
            pausa.f() # намалювати паузу
        ### перевірка чи досі мишка на паузі
        if mouse.g(p1) == True: # якщо миша торкається паузи:
            pasa = True # так
        else: # інакше:
            pasa = False # ні
        p = 0 # малювати паузу більше не можна
        # необхідні речі щоб екран не був просто чорним, а щось відбувалося
        pygame.display.update() # створити це все на екрані
        clock.tick(50) # цикл для перебування у паузі повторюється 50 разів на секунду
    #### цикл для перебування у програші
    while HP <= 5: # поки екран дуже червоний:
        for event in pygame.event.get(): # перегляд всіх подій
            if event.type == pygame.QUIT: # якщо ця подія це натискання на хрестик:
                a = 2 +'2' # надто складна математична задача через яку програма закриється
            elif True: #event.type == pygame.KEYDOWN: # якщо ми щось натиснули:
                HP = 225 # колір знов світло сірий
                start_i = 100 # куби появляються зноу дуже рідко
                kubas = 0 # куби за цю гру = 0
                i = 45 # 2 куби появляться через секунду
                x_lose += 1 # кількість програшів + 1
                for b in kubs: # перегляд всіх кубів з списку
                    kubs = [] # знищити всі куби
                    kubis(b) # створити по 3 частинки на місці куба
        #### необхідні речі щоб екран не був просто чорним, а щось відбувалося
        pygame.display.update() # створити це все на екрані
        clock.tick(5) # все під час паузи відбувається по 5 разів на секунду
    pygame.display.update() # створити це все на екрані
    clock.tick(45) # події відбуваються 45 разів на секунду (45 кадрів на секунду)
# Після закриття програми
